# ${license-info}
# ${developer-info}
# ${author-info}


package NCM::Component::xen;

#
# a few standard statements, mandatory for all components
#

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
use LC::Process qw (execute);

@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;

use EDG::WP4::CCM::Element;
use NCM::Check;

use File::Compare;
use File::Copy;
use File::Basename;


use constant { XENBASE   => "/etc/xen",
	       XENAUTO   => "/etc/xen/auto"
	       };




sub createConfigFile {
    our ($self, $domain_params, $filename, $createfs)=@_;

    my ($bufferr, $buffout);
    my @sorted_keys = sort { 
    if($a eq 'bootargs') { return 1; }
    elsif($b eq 'bootargs') { return -1; }
    else { return $a cmp $b; } 
    } (keys %$domain_params);

    my @vbdlist=[];

    foreach my $k (@sorted_keys) {
	my $v=$domain_params->{$k};

	if ($k eq 'disk') {
        @vbdlist=@$v;

        my $i =0;
        my $vbdstring="[";
        my @vbdstrlist=[];
	    
        foreach my $vbd (@vbdlist) {
        my %vbdhash=%$vbd;
		
        SetupVbds($self,$createfs,%vbdhash);
        $vbdstrlist[$i]=VbdParams(%vbdhash);                               
        $i++;
    }
    # print end of vbd params list
#                            print "@vbdstrlist\n";
	    $vbdstring.=join(',',@vbdstrlist);

	    $vbdstring.="]";
	    $self->verbose($vbdstring);
	    PrintSimpleParams($filename, $vbdstring, 'disk');

	} elsif ($k eq 'vif') {

	    my @viflist = @$v;
	    my $vifstring="[";
	    foreach my $vif (@viflist) {
		  $vif="'".$vif."'";
	    }
	    $vifstring.=join(',',@viflist);
	    $vifstring.="]";
	    
	    PrintSimpleParams($filename, $vifstring, 'vif');
	    


	} elsif ($k eq 'download') {

	    my @downloadlist = @$v;
	    foreach my $d (@downloadlist){
		my $dfile=$d;
		$self->verbose($dfile);
		execute(["$dfile"], "stderr" => \$bufferr, "stdout"=>\$buffout);
	    }
	} else {

	    my $name=$k;
	    my $value = $v;

	    $self->verbose("\t$k=$v");
	    if (index($value,'[') == -1) {
		$value="'".$value."'";
	    }
	    PrintSimpleParams($filename, $value, $k); # if ($k ne "bootloader");
#	    $value = "'restart'" if($k =~ /on_reboot/ || $k =~ /on_crash/);
#	    PrintSimpleParams($filename_start, $value, $k);

	}

    }
    $domain_params->{'vbd'}=\@vbdlist;


}

sub PrintSimpleParams  {
    our($filename, $param_value, $param)=@_;

    my $safe_param_value=$param_value;
    
    # escape square braces in the parameter
    $safe_param_value =~ s/(\[)/\\$1/g;
    $safe_param_value =~ s/(\])/\\$1/g;
    
    if ( ! -e $filename ) {
        open ( CONF,">$filename" );
        print CONF "#  -*- mode: python; -*-\n".
"#============================================================================\n".
"# Python configuration setup for 'xm create'.\n".
"# This script sets the parameters used when a domain is created using 'xm create'.\n".
"# You use a separate script for each domain you want to create, or\n".
"# you can set the parameters for the domain on the xm command line.\n".
"#\n".
"# Generated by ncm-xen at ".scalar(localtime)."\n".
"#============================================================================"
;
        close (CONF);
#        $self->log("$filename created");
    }
    
    NCM::Check::lines($filename,
                      backup => ".old",
                      linere => '^#?\s*'.$param.'(\s+|=).*',
                      goodre => '^\s*'.$param.'\s*=\s*'.$safe_param_value.'\s*',
                      good   => "$param = ".$param_value,
                      add => 'last'
                      );
    
    
    
}


sub SetupVbds {
    our ($self,$createfs,%vbdhash)=@_;

    my $type=$vbdhash{'type'};

    my $bufferr="", my $buffout="";

    if (! $createfs) {
	$self->verbose("Not creating filesystems as create_filesystems is false");
    }

#    print %vbdhash,"\n";

    if ($type eq 'lvm') {
        $self->verbose("Configuring VBD of type ".$type);
        
        # Check if hostdevice exists
        my $hostdevice=$vbdhash{'hostdevice'};

        $self->verbose("Checking if VG $hostdevice exists");        
        my $bufferr="", my $buffout="";
        execute(["vgs",$hostdevice], "stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0 && $vbdhash{'create'}) {
           #$self->error("Volume group $hostdevice does not exist");
              my $path=$vbdhash{'path'};
              $self->info("Volume group $hostdevice does not exist, will try to create on $path");

                 execute(["vgcreate", "$hostdevice","$path"],"stderr" => \$bufferr, "stdout"=>\$buffout);

        }
        else {

        
            # Check if hostvol exists
            my $hostvol=$vbdhash{'hostvol'};
            my $volsize=$vbdhash{'size'};
            
            $self->verbose("Checking if LV $hostvol exists");

            execute(["lvs",$hostdevice."/".$hostvol], "stderr" => \$bufferr, "stdout"=>\$buffout);
            if ($? != 0 && $vbdhash{'create'}) {
                $self->info("Logical volume $hostvol does not exist, will try to create");
                
                execute(["lvcreate", "-L", "${volsize}M", "-n", "$hostvol",  "$hostdevice"],"stderr" => \$bufferr, "stdout"=>\$buffout);
                
            }
        }
        
    }
    elsif ($type eq 'file') {
        $self->verbose( "Configuring VBD of type file");

        my $imagefilename=$vbdhash{'path'};
        # does the file exist?
        if (-e $imagefilename ) {

            $self->verbose("File $imagefilename exists");
            
            # check the size?
        }
        else {             # if not, create it using dd (very carefully)

            my $filesize=$vbdhash{'size'};
            $self->verbose("ile $imagefilename of size $filesize");
            # make the directory if it doesn't exist
            my($filename, $directories, $suffix) = fileparse($imagefilename);
            $self->verbose("Creating directory $directories");
            execute(["mkdir","-p",$directories],"stderr" => \$bufferr, "stdout"=>\$buffout);

            $self->verbose("Creating new file $imagefilename of size $filesize");
            execute(["dd","if=/dev/zero","of=$imagefilename","bs=1M","count=$filesize"],"stderr" => \$bufferr, "stdout"=>\$buffout);
    
        }
    }

}

# return a string with the vbd params formatted for Xen 
# config file
sub VbdParams {
    our (%vbdhash)=@_;
    my $vbdstr="";


    my $type=$vbdhash{'type'};

    if ($type eq 'lvm') {
        my $path=$vbdhash{'path'};
        my $rw=$vbdhash{'rw'};
        my $guestdev=$vbdhash{'guestdevice'};
        my $hostdevice=$vbdhash{'hostdevice'};
        my $hostvol=$vbdhash{'hostvol'};
        $vbdstr.="'phy:/dev/$hostdevice/$hostvol,$guestdev,$rw'";

    }
    elsif ($type eq 'file') {
        my $path=$vbdhash{'path'};
        my $rw=$vbdhash{'rw'};
        my $guestdev=$vbdhash{'guestdevice'};
        $vbdstr.="'file:$path,$guestdev,$rw'";
    }
    elsif ($type eq 'phy') {
        my $guestdev=$vbdhash{'guestdevice'};
        my $hostdevice=$vbdhash{'hostdevice'};
	my $rw=$vbdhash{'rw'};
	$vbdstr="'phy:/dev/$hostdevice,$guestdev,$rw'";
	
    }

    $vbdstr;
}

##########################################################################
sub Configure {
##########################################################################

    our ($self,$config)=@_;
    IsXenHere($self);
    
    my $base_path = '/software/components/xen/';

    my $path=$base_path.'domains';

    my $bufferr="", my $buffout="";

    my $configroot=$config->getElement($base_path);
    my $configtree=$configroot->getTree;
    my $createdoms=0;
    my $createfs=0;

    if (exists $configtree->{'create_domains'}) {
        $createdoms=$configtree->{'create_domains'};
    }

    if (exists $configtree->{'create_filesystems'}) {
        $createfs=$configtree->{'create_filesystems'};
    }

    if ($config->elementExists($path)) {
        $configroot = $config->getElement($path);
        my $domains=$configroot->getTree;
	

        # iterate over domains
        foreach my $domain_name (keys (%$domains)) {
            my $domain = $domains->{$domain_name};
            # process hash of domain parameters   
            my $domain_params_ref = $domain->{'options'};
            my %domain_params=%$domain_params_ref;
#            my $domain_name=$domain_params{'name'};
	    
	    
            my $filename="/etc/xen/".$domain_name;
            my $filename_start="/etc/xen/".$domain_name.".start";
            #	    next if (! SanityCheck($self,$config,$domain_name));
            
	       
            # set up standard config file
            $self->verbose("Configuring file $filename");
            createConfigFile($self, $domain_params_ref, $filename, $createfs);
            
            # set up install-specific config file
            if (exists $domain->{'install_options'}) {
                $domain_params_ref = $domain->{'install_options'};
                $self->verbose("Configuring file $filename_start");
                createConfigFile($self, $domain_params_ref, $filename_start);
            }

            # configure auto-start
            if (exists $domain->{'auto'} ) {

                my $auto=XENAUTO.'/'.$domain_name;
		
                if ($domain->{'auto'}) {
                    $self->verbose("Setting domain $domain_name to auto-start");
                    if (! -l $auto) {
                        symlink($filename,$auto);
                    }
                } 
                else {
                    if (-l $auto) {
                        unlink($auto);
                    }
                }
            }

            # check if domain is running and if not, create it
            if ($createdoms) {
                execute(["xm","list"],"stderr" => \$bufferr, "stdout"=>\$buffout);
                if ($? != 0) {
                    $self->verbose("Problem running Xen commands, can't create domains. xm output:\n".$buffout.$bufferr);
                } 
                else {
                    execute(["xm","list",$domain_name],"stderr" => \$bufferr, "stdout"=>\$buffout);
                    if ($? != 0) {
                        $self->verbose("Domain ".$domain_name." not running, will try to create it.");
                        execute(["xm","create",$domain_name],"stderr" => \$bufferr, "stdout"=>\$buffout);
                        if ($? != 0) {
                            $self->verbose("Problem creating ".$domain_name.": xm output:\n".$buffout.$bufferr);
                        }
                    }
                    else {
                        $self->verbose("Domain $domain_name already running: xm output".$buffout);
                    }
                }
            }
        }
    }

    ##
    ## network setup
    ##
    $path=$base_path.'network';
    if ($config->elementExists($path)) {
        $configroot = $config->getElement($path);
        my $network=$configroot->getTree;
        if (exists($network->{'removeqemunetworklibvirtautostart'}) && $network->{'removeqemunetworklibvirtautostart'}) {
            RemoveQemuNetworkLibvirtAutostart($self);
        }
        ## no else (yet)
        ## - maybe revert the renaming ?
        
        if (exists($network->{'bridges'})) {
            MakeMultiBridge($self,$network->{'bridges'});
        }
    }

#### real end of configure
}
##########################################################################
sub SanityCheck {
##########################################################################
#
# Here is a sanity check to make sure that the Virtual Machine that we want to start on this host
# is not already maybe running on a different host.
# This checks also make sure that the map is kept up to date in CDB, for management of Virtual Machines.
#
# A template should contain the following information:
#"/software/components/xen/guest_map/<virtual_machine_name>/guest_mac" = "00:16:3E:11:22:33";
#"/software/components/xen/guest_map/<virtual_machine_name>/hypervisor_name" = "<hypervisor_name>";
#
# The ckec is simply, for VM <virtual_machine_name> that has to start here,
# is "<hypervisor_name>" equal to 'hostname' ?
#

    use Sys::Hostname;

    our ($self,$config,$domain_name)=@_;
    my $base_path = '/software/components/xen/guest_map';

    my $path=$base_path;
    my %guests;
    my $checkOK = 0;
    my $host = hostname();
    $host =~ s/\..*//;

    if (! $config->elementExists($path)) {
        $self->warn("Path $path is not defined in CDB. Skipping Sanity Check !!!");
        $checkOK = 1;
    }
    if ($config->elementExists($path)) {
        my $configroot = $config->getElement($path);

        # iterate over guests
        while ($configroot->hasNextElement()) {
            my $el = $configroot->getNextElement();
            my $eln = $el->getName();
            if($eln eq $domain_name){
		$self->verbose("Found Xen Guest \"$eln\" in CDB map");
		my %guest_params = $el->getHash();
                $guests{$eln}=\%guest_params;
                foreach my $k (keys %guest_params) {
                    my $v=$guest_params{$k};
                    if ( $v->isProperty() ) {
                        my $name=$v->getName();
                        my $value = $v->getValue();
                        $guest_params{$k}=$value;
                        $self->verbose("\tparameter name: $k\tvalue: $value");
                        if($k eq "hypervisor_name"){
			    if ($value ne $host){
				$self->error("$domain_name does not have the correct hypervisor name in CDB: $value iso $host");
			    }
			    else{
				$checkOK = 1;
				$self->verbose("SanityCheck OK for hypervisor name \"$value\" for \"$domain_name\" ");
			    }
			} elsif($k eq "guest_mac"){
			    # not check yet
			}
                    }
                }
            }
        }
        if(! $checkOK){
               $self->error("No Guest $domain_name was found under $base_path. Cannot execute Sanity check.");
        }
    }
    $self->verbose("SanityCheck returns $checkOK");
    return $checkOK;

}



##########################################################################
sub RemoveQemuNetworkLibvirtAutostart {
##########################################################################
#
# Remove the libvirt qemud network autostart files
#
    my $self = shift;
    my $func = "RemoveQemuNetworkLibvirtAutostart";
    
    my $libvirt_basedir = "/etc/libvirt/qemu/networks";
    my $libvirt_autodir = "$libvirt_basedir/autostart";
    
    ##
    ## Rename all files to something not .xml
    ##
    
    if ( ! -d $libvirt_autodir ){
        $self->info("$func: no directory $libvirt_autodir.");
        ## this is a good thing (nothing will autostart)        
        return 1;
    }
    
    opendir(DH, $libvirt_autodir) || $self->error("$func: can't list directory $libvirt_autodir.");
    my @fs=readdir(DH);
    closedir(DH);

    foreach my $f (@fs) {
        my $ff = "$libvirt_autodir/$f";
        next unless (-f $ff || -l $ff);
        if ($f =~ /xml$/) {
            my $new="$ff.ncm-xen.dont_start";
            rename($ff, $new) unless (-e $new);
        }
    }   
    
    ##
    ## restart libvirt service
    ## - no need to remove it with chkconfig
    ## - who knows it's useful for somthing else
    ##  
    my $bufferr="", my $buffout="";
    my $serv="/etc/init.d/libvirtd";
    my $cmd="$serv restart";
    if (-f $serv) {
        execute([$serv,"restart"],"stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0) {
            $self->warn("$func: Problem restarting $serv: output:\n".$buffout.$bufferr);
        }
    }
    
    return 1;
}

##########################################################################
sub MakeMultiBridge {
##########################################################################
#
# Create the multibridge script
#
    my $self = shift;
    
    my $func = "MakeMultiBridge";
    my $xen_scripts_base = XENBASE."/scripts";
    my $bs_name = "network-bridge";
    my $bs = "$xen_scripts_base/$bs_name";
    my $bs_copy="$bs.ncm-xen";
    my $mbs_name = "$bs_name.multi-bridge.ncm-xen";
    my $mbs = "$xen_scripts_base/$mbs_name";
    my $xen_config = XENBASE."/xend-config.sxp";
    
    my $brs = shift;
    my %bridges = %$brs;
    
    if ( ! -f $bs) {
        ## ?
        $self->error("$func: can't find network-bridge-script $bs.");
        return 0;
    }
    
    if ( ! -f $bs_copy) {
        #make a copy
        if (! copy($bs,$bs_copy)) {
            $self->error("$func: can't create copy of $bs to $bs_copy");
            return 0;
        }
    }
    chmod 0755, $bs_copy;

    ## action
    ## looks like
    ## $action_prefix vifnum=0 bridge=xenbr0 netdev=eth0
    my $action_prefix='                $script "$OP"';
    my $action='';
    foreach my $br (sort(keys(%bridges))) {
        my $num="0";
        $num = $1 if ($br =~ m/xenbr(\d+)/);
        
        my $netdev="eth$num";
        my $vifnum=$num;
        
        if (exists($bridges{$br}{netdev})) {
            $netdev = $bridges{$br}{netdev};  
        }
        if (exists($bridges{$br}{vifnum})) {
            $vifnum = $bridges{$br}{vifnum};  
        }
        $action.="$action_prefix vifnum=$vifnum bridge=$br netdev=$netdev\n";
    }
        
    my $txt = <<EOF;
#!/bin/sh
##
## Generated by ncm-xen
##
## Classical multi-bridge-script
##

# Exit if anything goes wrong
set -e
# First arg is operation.
OP=\$1
shift
script=$bs_copy
case "\${OP}" in
        start|stop|status)
$action
                ;;

        *)
                echo 'Unknown command: ' \${OP}
                echo 'Valid commands are: start, stop, status'
                exit 1
esac


EOF
    
    ## filecopy style
    my $changes = LC::Check::file(
                                $mbs,
                                backup   => ".old",
                                contents => $txt,
                                mode => "0755",
    );
    $changes += LC::Check::status(
                                $mbs,
                                mode => "0755",
    );
    
    ## change xen config
    $changes += NCM::Check::lines( $xen_config,
                       linere => '^\s*\(\s*network-script\s+.*',
                       goodre => '^\s*\(\s*network-script\s+'.$mbs_name.'.*',
                       good   => "(network-script $mbs_name)",
                       keep   => 'first',
                       add    => 'last',
                       backup => '.old'
    );
    ##
    ## do something if changed? like restart the xen network?
    ##
    if ($changes) {
        $self->info("$func: something changed to either $mbs or $xen_config. Attempting a restart.");
        my $bufferr="", my $buffout="";
        execute([$mbs,"stop"],"stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0) {
            $self->warn("$func: Problem stopping $mbs: output:\n".$buffout.$bufferr);
        }
        ## start it anyway?
        execute([$mbs,"start"],"stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0) {
            $self->warn("$func: Problem starting $mbs: output:\n".$buffout.$bufferr);
        }
    }
     
    return 1;
}

##########################################################################
sub IsXenHere {
##########################################################################
#
# Test if Xen is avaible 
# - imagine debugging problems while you are working with non-xen kernel
#   (not that this ever happened in real life)
# - only print warnings
#
    my $func = "IsXenHere";
    my $self = shift;
    my $bufferr="", my $buffout="";
    
    my $exe='/usr/sbin/xm';
    if (-f $exe) {
        execute([$exe,"list"],"stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0) {
            $self->warn("$func: Problem with \"$exe list\": output:\n".$buffout.$bufferr);
        }
    } else {
        $self->warn("$func: $exe not found.");
    }
    
}



1;
