#${PMcomponent}

=head1 NAME

nfs: NCM component for /etc/exports and /etc/fstab

=head1 DESCRIPTION

The I<nfs> component manages entries for C<NFS> in the C</etc/exports>
and/or C<NFS>/C<NFSv4>/C<CephFS>/C<PanFS>/C<bind> mount in the C</etc/fstab> files.

=head1 Example

    prefix "/software/components/nfs";
    "exports" = append(dict(
        "path", "/shared/path/",
        "hosts", dict(
            "server*.example.org", "no_root_squash",
        ),
    ));

    "mounts" = append(dict(
        "device", "foreign.example.org:/shared/path/",
        "mountpoint", "/mnt/foreign",
        "fstype", "nfs",
        "options", "rw",
    ));

=cut

use parent qw(NCM::Component CAF::Path);
our $EC = LC::Exception::Context->new->will_store_all;

use CAF::Object qw(SUCCESS);
use CAF::FileWriter;
use CAF::FileReader;
use CAF::Service;

use EDG::WP4::CCM::Path qw(unescape);

use Readonly;

our $NoActionSupported = 1;

# The absolute names of configuration files.
Readonly my $EXPORTS => "/etc/exports";
Readonly my $FSTAB => "/etc/fstab";

Readonly my $EXPORTS_DEFAULT_SYNC => 'sync';

Readonly my $FSTAB_ACTION => 'action';

Readonly my $FSTAB_DEVICE => 'device';
Readonly my $FSTAB_MOUNTPOINT => 'mountpoint';
Readonly my $FSTAB_FSTYPE => 'fstype';
Readonly my $FSTAB_OPTIONS => 'options';
Readonly my $FSTAB_FREQ => 'freq';
Readonly my $FSTAB_PASSNO => 'passno';

Readonly::Array my @FSTAB_LINE => (
    $FSTAB_DEVICE, $FSTAB_MOUNTPOINT, $FSTAB_FSTYPE,
    $FSTAB_OPTIONS, $FSTAB_FREQ, $FSTAB_PASSNO,
);

Readonly::Hash my %FSTAB_DEFAULT => {
    $FSTAB_OPTIONS => 'defaults',
    $FSTAB_FREQ => 0,
    $FSTAB_PASSNO => 0,
};

Readonly my $FSTAB_ACTION_NONE => 'none';
Readonly my $FSTAB_ACTION_MOUNT => 'mount';
Readonly my $FSTAB_ACTION_REMOUNT => 'remount';
Readonly my $FSTAB_ACTION_UMOUNT_MOUNT => 'umount/mount';

Readonly::Array my @CMD_UMOUNT_LAZY => qw(umount -l);
Readonly::Array my @CMD_MOUNT => qw(mount);
Readonly::Array my @CMD_REMOUNT => qw(mount -o remount);

=head2 Functions

=over

=item mount_action_new_old

Compares two fstab hashref C<new> and C<old> for equality,
and returns mount action to be taken.

=over

=item If old does not exist, mount.

=item If equal, do nothing.

=item If the entries differ in the devices or mountpoint, do unmount/mount.

=item Otherwise, remount.

=back

=cut

sub mount_action_new_old
{
    my ($new, $old) = @_;

    my $action = $FSTAB_ACTION_REMOUNT;

    if ($old) {
        my %changed = map { $_ => 1 } grep { $new->{$_} ne $old->{$_} } @FSTAB_LINE;

        if (! %changed) {
            $action = $FSTAB_ACTION_NONE;
        } elsif ($changed{$FSTAB_DEVICE} || $changed{$FSTAB_MOUNTPOINT}) {
            $action = $FSTAB_ACTION_UMOUNT_MOUNT;
        };

    } else {
        $action = $FSTAB_ACTION_MOUNT;
    };

    return $action;
}


=item fstab_add_defaults

Given fstab hashref, add defaults for the undefined values
Returns a copy of the original hashref

=cut

sub fstab_add_defaults
{
    my $fstab = shift;

    # Use default values if undefined
    my %res = map {$_ => defined($fstab->{$_}) ?
                       $fstab->{$_} :
                       $FSTAB_DEFAULT{$_}} @FSTAB_LINE;

    return \%res;
};


=item parse_fstab_line

Parses a line of C</etc/fstab> and converts it
in a hashref.

Returns undef when the line is comment/empty.

Defaults are added using C<fstab_add_defaults> function.

=cut

sub parse_fstab_line
{
    my $line = shift;
    chomp($line);

    my $parsed;
    if ($line !~ m/^\s*(#.*)?$/) {
        my %fstab;
        # Not a comment or an empty line

        # Split and map the line using hashslice
        @fstab{@FSTAB_LINE} = split(/\s+/, $line);

        $parsed = fstab_add_defaults(\%fstab);
    };

    return $parsed;
};

=pod

=back

=head2 Methods

=over

=item exports

Given the component configuration hashref C<tree>,
create the exports configuration file C</etc/exports>.
A backup of the old file is created.

The method also sets the C<sync> option if nethier sync or async
is specified.

Returns if the configuration file changed (or not).

=cut

sub exports
{
    my ($self, $tree) = @_;

    my $fh = CAF::FileWriter->new($EXPORTS, backup => ".old", log => $self);

    # Do not include timestamp, otherwise file changes every run
    print $fh "#\n# File generated by ncm-nfs\n#\n";

    # Process exports to build /etc/exports

    my $exports = $tree->{exports};
    if ($exports) {
        # Pull out the parameters from the configuration.

        # Loop through all of the servers creating a line for each.
        foreach my $export (@{$exports}) {
            my $hosts = $export->{hosts};

            my @entries;
            foreach my $host_e (sort keys %$hosts) {
                my $host = unescape($host_e);
                my @export_opts = split(',', $hosts->{$host_e});

                # add option 'sync if neither 'sync', nor 'async' has been specified
                push(@export_opts, $EXPORTS_DEFAULT_SYNC) if ( ! grep {$_ =~ m/^a?sync$/} @export_opts);

                push(@entries, "$host(".join(',', @export_opts).")");
            }

            # Only actually write the line if there was at least one
            # valid host/option entry.
            if (@entries) {
                print $fh "$export->{path} ".join(' ', @entries)."\n";
            }
        }
    } else {
        $self->verbose("No exports defined");
        print $fh "# No exports defined\n";
    }

    my $result = $fh->close();
    if ($result) {
        $self->info("$EXPORTS created/updated");
    } else {
        $self->verbose("$EXPORTS unmodified");
    }

    return $result;
}

=item fstab

Given the component configuration hashref C<tree>,
create the fstab configuration file C</etc/fstab>.
A backup of the old file is created.

The fstab configuration file is read and processed. Any non-managed
entries (and comments not related to the component) are left alone.

Only managed entries are considered for removal or modifications;
new ones are added from the configuration.

The current managed entries are

=over

=item devices with filesystems C<nfs>, C<nfs4>, C<panfs> or C<cephfs>.

=item bind mounts (filesystem C<none> and mount option C<bind>)

=back

Method returns

=over

=item if the configuration file changed (or not)

=item hashref with the old managed entries
(key the device and value the fstab hashref
from C<parse_fstab_line> function)

=item arrayref with the order of the old managed devices \%new, \@new_order;

=item hashref with the configured managed entries (with defaults
and action to take added)

=item arrayref with the order of the configured devices

=back

=cut

# There is a certain risk if the schema allows for managed entries that are not managed
# They will be added/mounted the first run, and removed and readded the second run.

sub fstab
{
    my ($self, $tree) = @_;

    # Read in old configuration
    my $fh_old = CAF::FileReader->new($FSTAB, log => $self);
    my @fstab_lines = split("\n", "$fh_old");

    my $fh = CAF::FileWriter->new($FSTAB, backup => ".old", log => $self);

    # Keep updated with filter below
    my $mngd_by = "nfs/nfs4/panfs/cephfs filesystems and bind mounts";

    # Collect information for fstab file.
    print $fh "# File edited by ncm-nfs\n";
    print $fh "# Only $mngd_by managed by ncm-nfs component.\n";

    # Extract fstab information from existing file.
    my %old;
    my @old_order;
    foreach my $line (@fstab_lines) {
        # line does not end in newline (see split above)
        my $fstab = parse_fstab_line($line);
        if ($fstab) {
            if ( ($fstab->{$FSTAB_FSTYPE} =~ m/^(nfs4?|(pan|ceph)fs)$/) ||
                 (($fstab->{$FSTAB_FSTYPE} eq 'none') && ($fstab->{$FSTAB_OPTIONS} eq 'bind')) ) {
                # It is an ncm-nfs managed entry, save the information.
                $old{$fstab->{$FSTAB_DEVICE}} = $fstab;
                push(@old_order, $fstab->{$FSTAB_DEVICE});
            } else {
                # fstab entry not under ncm-nfs control; add the line as is.
                print $fh $line, "\n";
            }
        } else {
            # Keep blank lines or comments in the output file, although
            # leave out anything with the component name in it to avoid
            # ever growing file.
            print $fh $line, "\n" if ($line !~ m/ncm-nfs/);
        };
    }

    # Now check the information given in the configuration.  Make sure
    # that the configuration is preserved.
    my %new;
    my @new_order;

    my $mounts = $tree->{mounts};
    if ( $mounts ) {
        # Loop through all of the servers creating a line for each.
        foreach my $mount (@$mounts) {
            my $device = $mount->{$FSTAB_DEVICE};
            # store the device order

            push(@new_order, $device);

            $new{$device} = fstab_add_defaults($mount);
        }
    } else {
        $self->verbose("No mounts configured");
    }

    # Add to the configuration file the new NFS locations, creating
    # the new mount points as necessary. At the same time determine
    # what action will need to be taken (none, mount, unmount/mount,
    # or remount).
    foreach my $device ( @new_order ) {
        print $fh join(' ', map {$new{$device}->{$_}} @FSTAB_LINE)."\n";

        # If the directory doesn't exist, then create it.
        # Issue a warning if this couldn't be done.
        my $mntpt = $new{$device}->{$FSTAB_MOUNTPOINT};
        if (! $self->directory($mntpt)) {
            $self->error("Failed to create mountpoint $mntpt: $self->{fail}");
        }

        $new{$device}->{$FSTAB_ACTION} = mount_action_new_old($new{$device}, $old{$device});
    }

    my $result = $fh->close();
    if ($result) {
        $self->info("$FSTAB created/updated");
    } else {
        $self->verbose("$FSTAB unmodified");
    }

    return $result, \%old, \@old_order, \%new, \@new_order;
}


=item do_mount

Do something mount(point) related (umount, mount, remount, ...)
C<cmd> is the arrayref, the mountpoint is appended from the C<fstab> hashref.

Returns SUCCESS on success, undef on failure.

=cut

sub do_mount
{
    my ($self, $cmd, $fstab) = @_;

    # Make a copy of the $cmd ref (if a Readonly array is passed,
    # pushargs to readonly will fail)
    my $proc = CAF::Process->new([@$cmd], log => $self);
    $proc->pushargs($fstab->{$FSTAB_MOUNTPOINT});
    $proc->execute();
    if ($?) {
        $self->warn("Error (un/re)mounting ", $fstab->{$FSTAB_MOUNTPOINT},
                    " (device ", $fstab->{$FSTAB_DEVICE}, ", cmd $proc)");
        return;
    } else {
        return SUCCESS;
    }
}

=item process_mounts

Given the component configuration hashref C<tree>,
determine the new and old ncm-nfs managed entries via
the C<fstab> method and do the appropriate unmounting/mounting.

Returns

=over

=item if the fstab configuration file changed (or not)
(value from C<fstab> method)

=item if any mount action was taken

=back

=cut

sub process_mounts
{
    my ($self, $tree) = @_;

    my ($fstab_changed, $old, $old_order, $new, $new_order) = $self->fstab($tree);

    # Unmount the file systems which are going away.
    # Unmount in the reverse order that the file systems are defined.
    my $action_taken = 0;

    foreach my $device ( reverse @$old_order ) {
        # Unmount volume ONLY if new entry doesn't exist or the
        # mount point has changed.
        if (! defined($new->{$device}) ||
            ($new->{$device}->{$FSTAB_ACTION} eq $FSTAB_ACTION_UMOUNT_MOUNT) ) {

            $action_taken = 1;
            $self->do_mount(\@CMD_UMOUNT_LAZY, $old->{$device});
        }
    }

    # Mount or remount as appropriate.
    foreach my $device ( @$new_order ) {
        my $action = $new->{$device}->{$FSTAB_ACTION};

        # Perform the necessary action.
        if (($action eq $FSTAB_ACTION_MOUNT) ||
            ($action eq $FSTAB_ACTION_UMOUNT_MOUNT)) {
            $action_taken = 1;
            $self->do_mount(\@CMD_MOUNT, $new->{$device})
        } elsif ($action eq $FSTAB_ACTION_REMOUNT) {
            $action_taken = 1;
            $self->do_mount(\@CMD_REMOUNT, $new->{$device})
        } else {
            $self->verbose("No action needed for ", $new->{$device}->{$FSTAB_MOUNTPOINT});
        }
    }

    return $fstab_changed, $action_taken;
}

sub Configure
{
    my ($self, $config) = @_;

    # Load ncm-nfs configuration into a hash
    my $tree = $config->getTree($self->prefix());

    if (! exists($tree->{server}) || $tree->{server}) {
        if ($self->exports($tree))  {
            # Force a reload of the nfs daemon.
            $self->info("Forcing nfs reload");
            # report error on failure
            CAF::Service->new(["nfs"], log => $self)->reload();
        };
    } else {
        $self->verbose("Not a NFS server configuration");
    };

    $self->process_mounts($tree);

    return 1;
}

=pod

=back

=cut

1;      # Required for PERL modules
