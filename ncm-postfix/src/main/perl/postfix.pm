# ${license-info}
# ${developer-info}
# ${author-info}
# ${build-info}

package NCM::Component::postfix;

use strict;
use warnings;

use base qw(NCM::Component);

use LC::Exception;
use LC::Find;
use LC::File qw(copy makedir);

use EDG::WP4::CCM::Element;
use CAF::FileWriter;
use CAF::FileEditor;
use CAF::Process;
use File::Basename;
use File::Path;
use Template;
use Readonly;

Readonly::Array my @RESTART => qw(/sbin/service postfix restart);
Readonly::Hash my %FILES => {
			     main => { file => "/etc/postfix/main.cf",
				       template => "postfix/main.tt" },
			     master => { file => "/etc/postfix/master.cf",
					 template => "postfix/master.tt" },
			     dbs => {
				     ldap => {
					      template => "postfix/ldap.tt" }
				    }
			    };

Readonly::Scalar my $DBS_BASE => "/etc/postfix/";


our $EC=LC::Exception::Context->new->will_store_all;



# Restart the process.
sub restart_postfix {
    my ($self) = @_;
    CAF::Process->new(\@RESTART, log => $self)->run();
    return !$?;
}

# Fills a configuration file from the profile subtree $tree. The file
# and templates
sub handle_config_file
{
    my ($self, $tree, $files) = @_;
    my $fh = CAF::FileWriter->new($files->{file}, log => $self);
    printf $fh "# File generated by %s. Do not edit\n", __PACKAGE__;
    if (!$self->template()->process($files->{template}, $tree, $fh)) {
	$self->error("Unable to process template for $files->{file}: ",
		     $self->template()->error());
	$fh->cancel();
	return;
    }
    return 1;
}

sub handle_databases
{
    my ($self, $tree) = @_;

    my $ok = 1;

    while (my ($dbtype, $dbs) = each(%$tree)) {
	$self->verbose("Generating configuration for databases of type $dbtype");
	my $tpl = $FILES{dbs}->{$dbtype}->{template};
	while (my ($db, $dbcfg) = each(%$dbs)) {
	    $self->verbose("Configuring access to database $dbtype: $db");
	    my $fh = CAF::FileWriter->new($DBS_BASE . $db, log => $self);
	    printf $fh "# File generated by %s. Do not edit\n", __PACKAGE__;
	    if (!$self->template()->process($tpl, $dbcfg, $fh)) {
		$self->error("Unable to process template for database $db",
			     $self->template()->error());
		$fh->cancel();
		$ok = undef;
	    }
	    #$fh->close();
	}
    }
    return $ok;
}

sub Configure {
    my ($self, $config, $base) = @_;

    my $ok = 1;
    my $t = $config->getElement($base)->getTree();
    $self->handle_config_file($t, $FILES{master}) or $ok = 0;
    $self->handle_config_file($t->{main}, $FILES{main}) or $ok = 0;
    if (exists($t->{databases})) {
	$self->handle_databases($t->{databases}) or $ok = 0;
    }
    $self->restart_postfix() or $ok = 0;
    return $ok;
}

1; # Required for perl module!
